前端
1.存储登录凭证：
  ①localStorage：存储长期需要的登录凭证；
  ②sessionStorage：存储临时会话的登录凭证；
  ③cookies：存储需要与服务器通信的重要信息，如登录状态或会话标识。
2.判断登录状态：
  ①路由守卫：需要判断的路由meta中添加requiresAuth: true，在路由守卫中判断requiresAuth是否为true且token是否存在
  ②状态工具管理
3，发送请求时携带登录凭证：token存在的话，请求头部header设置Authorization=`自定义名称 ${token}`

后端
1.提供登录接口,验证登录凭证
验证用户名密码是否正确，验证成功后返回登录凭证（token或session id）
2.处理登录状态：后端在用户访问受保护资源时，验证用户的登录状态。
  ①从请求头提取token，验证有效性。如果token无效或者过期，返回401或403状态码。
  ②如果token有效，则根据用户的权限，决定是否允许访问受保护的资源。

前端如何判断登录状态是否失效
  方式
      ①检查token本地是否存在
      ②如果给token设置了有效期，检查是否过期
      ③处理服务器返回的token失效响应码
  场景
      ①跳转需要登录页面时，检查token是否存在或过期
      ②发送请求前检查token是否存在过期
      ③处理服务器返回的token失效验证码

后端如何验证token是否过期
1.生成token，通过jsonwebtoken库省内从token，并在payload中设置之用户信息和过期时间
jwt.sin({用户id、用户role、等}，密钥、{ expiresIn: '1h' })
2.通过中间件验证token。从请求头取出token，通过jwt.verify验证token是否有效且没过期
3.通过中间件验证当前用户是否有权限访问。两种设计思路，rbac（基于角色的访问控制）-在token中存储角色和abac（基于属性的访问控制）-从数据库动态查询用户权限

--------------------------------------------------------------------------------------
什么是jwt
RBAC和ABAC区别
安全性：使用 HTTPS 防止 Token 被截获、设置较短的 Token 过期时间，结合 Refresh Token 机制（需额外实现）
性能优化：频繁查询权限时可使用缓存（如 Redis）。